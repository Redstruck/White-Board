import React, { useRef, useEffect, useState, useCallback } from 'react';

export default function Canvas({
  objects,
  selectedObjectId,
  currentTool,
  pencilSettings,
  onObjectsChange,
  onSelectedObjectChange,
  onAddObject,
  viewport,
  onViewportChange,
  background = 'white',
}) {
  const canvasRef = useRef(null);
  const contextRef = useRef(null);
  const [isDrawing, setIsDrawing] = useState(false);
  const [currentPath, setCurrentPath] = useState([]);
  const [isDragging, setIsDragging] = useState(false);
  const [dragStart, setDragStart] = useState(null);

  // Helper functions moved outside of useCallback dependencies
  const drawBackground = useCallback((context, canvas) => {
    const width = 1280;  // logical canvas size
    const height = 720;
    
    if (background === 'white') {
      context.fillStyle = '#FFFFFF';
      context.fillRect(0, 0, width, height);
    } else if (background === 'black') {
      context.fillStyle = '#000000';
      context.fillRect(0, 0, width, height);
    } else if (background === 'grid') {
      context.fillStyle = '#FFFFFF';
      context.fillRect(0, 0, width, height);
      
      // Draw grid
      context.strokeStyle = '#E5E5E5';
      context.lineWidth = 1;
      const gridSize = 20;
      
      for (let x = 0; x <= width; x += gridSize) {
        context.beginPath();
        context.moveTo(x, 0);
        context.lineTo(x, height);
        context.stroke();
      }
      
      for (let y = 0; y <= height; y += gridSize) {
        context.beginPath();
        context.moveTo(0, y);
        context.lineTo(width, y);
        context.stroke();
      }
    }
  }, [background]);

  const drawObject = useCallback((context, obj, isSelected = false) => {
    if (obj.type === 'stroke') {
      context.save();
      
      // Apply transform
      if (obj.transform) {
        const bbox = getObjectBoundingBox(obj);
        const centerX = bbox.x + bbox.width / 2;
        const centerY = bbox.y + bbox.height / 2;
        
        context.translate(centerX + obj.transform.x, centerY + obj.transform.y);
        context.scale(obj.transform.scaleX || 1, obj.transform.scaleY || 1);
        context.rotate((obj.transform.rotation || 0) * Math.PI / 180);
        context.translate(-centerX, -centerY);
      }

      context.strokeStyle = obj.style.color || '#000000';
      context.lineWidth = (obj.style.width || 2) * (obj.transform?.scaleX || 1);
      context.globalAlpha = obj.style.alpha || 1;

      if (obj.points && obj.points.length > 1) {
        context.beginPath();
        context.moveTo(obj.points[0].x, obj.points[0].y);
        
        for (let i = 1; i < obj.points.length; i++) {
          context.lineTo(obj.points[i].x, obj.points[i].y);
        }
        
        context.stroke();
      }
      
      context.restore();
    } else if (obj.type === 'text') {
      context.save();
      
      if (obj.transform) {
        context.translate(obj.transform.x || 0, obj.transform.y || 0);
        context.scale(obj.transform.scaleX || 1, obj.transform.scaleY || 1);
        context.rotate((obj.transform.rotation || 0) * Math.PI / 180);
      }

      context.fillStyle = obj.style.color || '#000000';
      context.font = `${obj.style.fontSize || 16}px ${obj.style.fontFamily || 'Arial'}`;
      context.fillText(obj.text || '', 0, 0);
      
      context.restore();
    }
  }, []);

  const getObjectBoundingBox = (obj) => {
    if (obj.type === 'stroke' && obj.points && obj.points.length > 0) {
      let minX = obj.points[0].x;
      let minY = obj.points[0].y;
      let maxX = obj.points[0].x;
      let maxY = obj.points[0].y;

      obj.points.forEach(point => {
        minX = Math.min(minX, point.x);
        minY = Math.min(minY, point.y);
        maxX = Math.max(maxX, point.x);
        maxY = Math.max(maxY, point.y);
      });

      const padding = (obj.style?.width || 2) / 2;
      return {
        x: minX - padding,
        y: minY - padding,
        width: maxX - minX + padding * 2,
        height: maxY - minY + padding * 2,
      };
    }
    
    if (obj.type === 'text') {
      const fontSize = obj.style?.fontSize || 16;
      const textWidth = (obj.text || '').length * fontSize * 0.6; // rough estimation
      return {
        x: obj.transform?.x || 0,
        y: (obj.transform?.y || 0) - fontSize,
        width: textWidth,
        height: fontSize,
      };
    }
    
    return { x: 0, y: 0, width: 0, height: 0 };
  };

  const drawSelectionHandles = useCallback((context, obj) => {
    const bbox = getObjectBoundingBox(obj);
    const transform = obj.transform || { x: 0, y: 0, scaleX: 1, scaleY: 1, rotation: 0 };
    
    context.save();
    
    // Transform to screen coordinates
    context.translate(viewport.x, viewport.y);
    context.scale(viewport.zoom, viewport.zoom);
    
    const centerX = bbox.x + bbox.width / 2;
    const centerY = bbox.y + bbox.height / 2;
    
    context.translate(centerX + transform.x, centerY + transform.y);
    context.scale(transform.scaleX, transform.scaleY);
    context.rotate(transform.rotation * Math.PI / 180);
    context.translate(-centerX, -centerY);

    // Draw bounding box
    context.strokeStyle = '#3B82F6';
    context.lineWidth = 2 / viewport.zoom;
    context.setLineDash([5, 5]);
    context.strokeRect(bbox.x, bbox.y, bbox.width, bbox.height);
    context.setLineDash([]);

    // Draw corner handles
    const handleSize = 8 / viewport.zoom;
    const handles = [
      { x: bbox.x, y: bbox.y, type: 'nw' },
      { x: bbox.x + bbox.width, y: bbox.y, type: 'ne' },
      { x: bbox.x + bbox.width, y: bbox.y + bbox.height, type: 'se' },
      { x: bbox.x, y: bbox.y + bbox.height, type: 'sw' },
    ];

    context.fillStyle = '#FFFFFF';
    context.strokeStyle = '#3B82F6';
    handles.forEach(handle => {
      context.fillRect(handle.x - handleSize/2, handle.y - handleSize/2, handleSize, handleSize);
      context.strokeRect(handle.x - handleSize/2, handle.y - handleSize/2, handleSize, handleSize);
    });

    // Draw rotation handle
    const rotationHandle = {
      x: centerX,
      y: bbox.y - 30 / viewport.zoom,
      type: 'rotate'
    };
    context.fillStyle = '#FFFFFF';
    context.strokeStyle = '#3B82F6';
    context.beginPath();
    context.arc(rotationHandle.x, rotationHandle.y, handleSize/2, 0, 2 * Math.PI);
    context.fill();
    context.stroke();

    context.restore();
  }, [viewport]);

  const redraw = useCallback(() => {
    const canvas = canvasRef.current;
    const context = contextRef.current;
    if (!canvas || !context) return;

    // Clear canvas
    context.clearRect(0, 0, canvas.width, canvas.height);

    // Apply viewport transform
    context.save();
    context.translate(viewport.x, viewport.y);
    context.scale(viewport.zoom, viewport.zoom);

    // Draw background
    drawBackground(context, canvas);

    // Draw objects
    objects.forEach(obj => {
      drawObject(context, obj, obj.id === selectedObjectId);
    });

    context.restore();

    // Draw selection handles
    if (selectedObjectId) {
      const selectedObj = objects.find(obj => obj.id === selectedObjectId);
      if (selectedObj) {
        drawSelectionHandles(context, selectedObj);
      }
    }
  }, [objects, selectedObjectId, viewport, drawBackground, drawObject, drawSelectionHandles]);

  // Initialize canvas
  useEffect(() => {
    const canvas = canvasRef.current;
    if (!canvas) return;

    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight - 60; // Account for top bar

    const context = canvas.getContext('2d');
    context.lineCap = 'round';
    context.lineJoin = 'round';
    contextRef.current = context;

    redraw();
  }, [redraw]);

  // Redraw canvas when objects change
  useEffect(() => {
    redraw();
  }, [redraw]);

  const getCanvasPoint = (e) => {
    const canvas = canvasRef.current;
    const rect = canvas.getBoundingClientRect();
    const x = (e.clientX - rect.left - viewport.x) / viewport.zoom;
    const y = (e.clientY - rect.top - viewport.y) / viewport.zoom;
    return { x, y };
  };

  const hitTestObject = (point, obj) => {
    if (obj.type === 'stroke' && obj.points) {
      // Simple bounding box hit test for now
      const bbox = getObjectBoundingBox(obj);
      const transform = obj.transform || { x: 0, y: 0, scaleX: 1, scaleY: 1, rotation: 0 };
      
      // Apply transform to point for hit testing
      let testX = point.x - transform.x;
      let testY = point.y - transform.y;
      
      return testX >= bbox.x && testX <= bbox.x + bbox.width &&
             testY >= bbox.y && testY <= bbox.y + bbox.height;
    }
    return false;
  };

  const findObjectAtPoint = (point) => {
    // Search from top to bottom (reverse order)
    for (let i = objects.length - 1; i >= 0; i--) {
      if (hitTestObject(point, objects[i])) {
        return objects[i];
      }
    }
    return null;
  };

  const handleMouseDown = (e) => {
    const point = getCanvasPoint(e);

    if (currentTool === 'cursor') {
      const hitObject = findObjectAtPoint(point);
      if (hitObject) {
        onSelectedObjectChange(hitObject.id);
        setIsDragging(true);
        setDragStart(point);
      } else {
        onSelectedObjectChange(null);
        // Start panning
        setIsDragging(true);
        setDragStart(point);
      }
    } else if (currentTool === 'pencil' || currentTool === 'highlighter') {
      setIsDrawing(true);
      setCurrentPath([point]);
    } else if (currentTool === 'eraser') {
      const hitObject = findObjectAtPoint(point);
      if (hitObject) {
        const newObjects = objects.filter(obj => obj.id !== hitObject.id);
        onObjectsChange(newObjects);
        if (selectedObjectId === hitObject.id) {
          onSelectedObjectChange(null);
        }
      }
    } else if (currentTool === 'text') {
      // Add text object
      const newTextObj = {
        id: 'text_' + Date.now(),
        type: 'text',
        tool: 'text',
        text: 'Text',
        style: {
          fontSize: 16,
          fontFamily: 'Arial',
          color: '#000000',
        },
        transform: {
          x: point.x,
          y: point.y,
          scaleX: 1,
          scaleY: 1,
          rotation: 0,
        },
        z: objects.length,
        createdAt: new Date().toISOString(),
      };
      onAddObject(newTextObj);
      onSelectedObjectChange(newTextObj.id);
    }
  };

  const handleMouseMove = (e) => {
    const point = getCanvasPoint(e);

    if (isDrawing && (currentTool === 'pencil' || currentTool === 'highlighter')) {
      setCurrentPath(prev => [...prev, point]);
    } else if (isDragging && currentTool === 'cursor') {
      if (selectedObjectId) {
        // Move selected object
        const deltaX = point.x - dragStart.x;
        const deltaY = point.y - dragStart.y;
        
        const newObjects = objects.map(obj => {
          if (obj.id === selectedObjectId) {
            return {
              ...obj,
              transform: {
                ...obj.transform,
                x: (obj.transform?.x || 0) + deltaX,
                y: (obj.transform?.y || 0) + deltaY,
              }
            };
          }
          return obj;
        });
        
        onObjectsChange(newObjects);
        setDragStart(point);
      } else {
        // Pan viewport
        const deltaX = (point.x - dragStart.x) * viewport.zoom;
        const deltaY = (point.y - dragStart.y) * viewport.zoom;
        
        onViewportChange({
          ...viewport,
          x: viewport.x + deltaX,
          y: viewport.y + deltaY,
        });
        setDragStart(point);
      }
    }
  };

  const handleMouseUp = () => {
    if (isDrawing && currentPath.length > 1) {
      const color = currentTool === 'highlighter' ? '#F7D153' : pencilSettings.color;
      const alpha = currentTool === 'highlighter' ? 0.25 : 1;
      
      const newStrokeObj = {
        id: 'stroke_' + Date.now(),
        type: 'stroke',
        tool: currentTool,
        points: currentPath,
        style: {
          color,
          width: pencilSettings.width,
          alpha,
        },
        transform: {
          x: 0,
          y: 0,
          scaleX: 1,
          scaleY: 1,
          rotation: 0,
        },
        z: objects.length,
        createdAt: new Date().toISOString(),
      };
      
      onAddObject(newStrokeObj);
    }

    setIsDrawing(false);
    setCurrentPath([]);
    setIsDragging(false);
    setDragStart(null);
  };

  // Draw current path while drawing
  useEffect(() => {
    if (isDrawing && currentPath.length > 1) {
      const canvas = canvasRef.current;
      const context = contextRef.current;
      if (!canvas || !context) return;

      redraw();

      // Draw current path
      context.save();
      context.translate(viewport.x, viewport.y);
      context.scale(viewport.zoom, viewport.zoom);

      const color = currentTool === 'highlighter' ? '#F7D153' : pencilSettings.color;
      const alpha = currentTool === 'highlighter' ? 0.25 : 1;
      
      context.strokeStyle = color;
      context.lineWidth = pencilSettings.width;
      context.globalAlpha = alpha;
      context.beginPath();
      context.moveTo(currentPath[0].x, currentPath[0].y);
      
      for (let i = 1; i < currentPath.length; i++) {
        context.lineTo(currentPath[i].x, currentPath[i].y);
      }
      
      context.stroke();
      context.restore();
    }
  }, [currentPath, isDrawing, currentTool, pencilSettings, viewport, redraw]);

  return (
    <div className="absolute inset-0 pt-16">
      <canvas
        ref={canvasRef}
        className="cursor-crosshair"
        onMouseDown={handleMouseDown}
        onMouseMove={handleMouseMove}
        onMouseUp={handleMouseUp}
        onMouseLeave={handleMouseUp}
      />
    </div>
  );
}

 
